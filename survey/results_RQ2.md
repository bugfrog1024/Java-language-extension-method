# RQ2：Java智能合约常见漏洞及预防措施

经过调研，本小节总结了13种使用Java开发智能合约的常见漏洞，其类型、成因和预防措施清单如表1所示。后续将针对这些漏洞在Java语言扩展方法中嵌入预防机制。

表1：

\begin{table}[htb]\footnotesize
\centering
\caption{Java智能合约常见漏洞清单}
\vspace{2mm}
\begin{tabular}{lll}
\toprule
漏洞类型&漏洞成因&预防措施\\
\hline
重入&攻击者重复调用合约函数，转移大量资产&检查-更新-交互模式；重入锁\\
\hline
权限访问控制&攻击者能够访问不该访问到的函数或变量&修饰器；函数逻辑限制权限\\
\hline
伪随机&随机性不足，导致执行结果可预测&链下随机数；SecureRandom\\
\hline
整数溢出&超出整数取值范围，导致计算结果不可靠&前置条件；向上转换；BigInteger\\
\hline
未检查的返回值&不安全函数可能得到意外的返回值&强制检查\\
\hline
随机数生成&在敏感操作中生成随机值，导致不确定性&避免随机数函数\\
\hline
时间戳依赖&在敏感操作中依赖时间戳，导致不确定性&避免时间戳函数\\
\hline
集合迭代顺序&集合每次迭代的顺序不确定&迭代顺序确定的集合；排序\\
\hline
程序并发&可能出现顺序冲突导致执行结果不确定&避免并发函数；事务触发器；队列\\
\hline
内存地址使用&各节点的具体内存地址可能不一致&避免使用具体的内存地址\\
\hline
系统命令执行&各节点执行系统命令的结果可能不一致&避免调用；异常处理\\
\hline
外部文件访问&各节点访问外部文件的结果可能不一致&避免访问；使用数据库\\
\hline
环境变量获取&各节点的环境变量可能不一致&避免获取；使用数据库\\
\bottomrule
\end{tabular}
\label{表-Java智能合约常见的漏洞清单}
\end{table}

- 重入。重入是智能合约中最常见的一种漏洞，攻击者通过循环或递归，重复调用包含账本写入操作的合约函数，将合约中的资产转走或铸造大量代币。2016年的The DAO事件就是由重入漏洞引起，被黑客利用，反复转账直至Gas耗尽，导致价值大约6000万美元的以太币流失。重入漏洞的预防措施目前主要有两种，检查-影响-交互模式和重入锁。检查-更新-交互模式强调在编写函数时，首先检查状态变量比如余额是否符合要求，紧接着更新状态变量，最后再和其他合约交互。重入锁是一种防止重入函数的修饰器，它包含一个状态变量，用于防止函数在调用结束前的第二次调用。
- 权限访问控制。合约的权限访问控制漏洞大多是由于没有合理地设置函数或变量的可见性，导致攻击者能够访问不该访问到的函数或变量。智能合约中的权限管理定义了不同角色在应用中的权限。通常来说，账本写入、资产转移等函数需要较高权限的用户才能调用。权限访问控制漏洞的预防措施有两种，第一种是使用权限管理库给合约的特殊函数配置相应的权限，通过使用修饰器使得只有合约所有者才能调用该函数；第二种是在函数的处理逻辑中确保合约调用者拥有足够的权限。
- 伪随机。也有学者称之为区块变量依赖、随机性不足或者可预测的随机处理。顾名思义，伪随机是指并非真正的随机数，一般利用区块时间戳、区块号等区块信息来产生。而这些信息在区块链上公开，可以被链上的任何人获知，这就导致随机数可预测，攻击者可以事先计算这些伪随机数的结果，从而达到想要的目的，那么所有基于随机性的安全保障将不复存在。伪随机漏洞可以使用链下随机数来预防，这类随机数在链下生成，然后上传到链上，从而保证随机数的不可预测。对于Java而言，Random类生成的是伪随机数，其以当前时间戳作为种子，而SecureRandom类会收集一些随机事件作为随机种子，可以看作是生成真正随机数的一个工具类。
- 整数溢出。整数溢出是大部分程序语言的通病, 根本原因是语言对于整数类型的存储空间有长度限制, 因此其所能表示的整数类型也有相应的大小限制，若超出取值范围，则会导致计算结果不可靠。整数溢出包括加法上溢、减法下溢和乘法上溢三种类型。同样Java语言中也存在整数溢出的情况。在Java中，有一些技术可以避免整数溢出，包括前置条件测试、向上转换和BigInteger。前置条件测试通过检查进入算术运算或表达式的值，以确保这些值不会发生溢出。向上转换通过判断结果是否超出整数的最大值或最小值，从而决定是否使用范围更大的类型来执行算术运算或表达式。BigInteger技术通过使用BigInteger类的方法进行算术运算，其底层基于字符串包装实现，因此永远不会溢出。
- 未检查的返回值。当函数调用中发生异常时，通常会向上传播，但是有些不安全的函数调用发生非预期情况时，并不抛出异常，比如在HF中账本读取的键不存在时，仅仅只是返回空值。因此如果没有检查这些函数调用的返回值，则可能导致在失败的调用后误以为成功调用，并继续执行合约后续操作，这极易产生漏洞。预防措施是对于不安全函数的返回值着重检查，确保所有可能的异常都被合理地处理。

当提供相同的输入时，一个不确定性的程序可能在两次运行时产生不同的输出。不确定性在Java中普遍存在，除了使用并行或随机数相关的类和方法会显而易见地造成不确定性之外，一些看起来顺序执行的方法也可能导致不确定性的结果，这也是传统软件中很多错误的根源。在智能合约场景下，这种情况更加不可容忍，任意两个不同的区块链节点执行相同代码，必须产生相同的结果。否则，对于大多数区块链而言，会导致节点无法达成共识，进而导致网络的分叉，而对于HF而言，不确定性的代码执行时会被拒绝。因此，如果开发人员希望合约正常运行，就应该避免不确定性。具体而言，下面八种漏洞均会导致不确定性。

- 随机数生成。对于大多数区块链而言，智能合约会在每个节点中独立执行，因此随机生成的数值对于每个节点均不同，具有不确定性。预防措施是若非必要，尽量避免使用随机数函数，尤其注意避免在账本写入操作中生成随机值。
- 时间戳依赖。与随机数生成类似，不能保证每个区块链节点同时调用时间戳函数，因此不能保证确定性。当合约使用时间戳作为条件的一部分来执行涉及账本读写的关键操作或作为生成随机数的种子时，时间戳依赖漏洞就会存在。类似的，预防措施是尽量避免使用时间戳函数。
- 集合迭代顺序。在很多编程语言中，某些集合类型在每次执行时都不能保证固定的迭代顺序。预防措施是使用迭代顺序确定的集合类型作为替代，或者在迭代之前对集合的键值进行排序，从而使迭代有序化。
- 程序并发。如果并发程序未得到适当处理，则很容易出现顺序冲突从而导致执行结果的不确定性。最简单的预防措施是尽量避免使用并发函数。此外，还可以使用事务触发器，在当前事务完成之前禁止其他事务执行。或者使用先进先出队列，避免事务的执行顺序冲突。
- 内存地址使用。有些方法使用了对象的具体内存地址，而内存地址取决于环境，也就是说，在不同的执行环境中，取值也就不同，即不能保证区块链各节点在独立环境中返回相同的结果。预防措施是尽量避免使用包含了对于具体的内存地址进行操作的函数。
- 系统命令执行。通过代码调用命令行，执行系统命令，但这涉及到了区块链外部环境的操作，因此不能保证在各节点之间得到相同的执行结果。预防措施是尽量避免调用系统命令，若必要，也应做好异常处理。
- 外部文件访问。通过代码访问外部文件，这同样涉及到了区块链外部环境的操作，带来了各节点之间执行的不确定性。预防措施是尽量避免对外部文件的访问，可以使用暂态数据和状态数据库存储文件数据。
- 环境变量获取。环境变量在不同执行环境中同样无法保证一致性。类似的，预防措施是尽量避免在代码中获取环境变量。或者说，避免在环境变量中存储重要信息，可以使用数据库代替。

从不确定性的来源考虑，上述八种漏洞可以分为来自语言指令的不确定性和来自外部访问的不确定性两大类，分别对应前五种和后三种。而从不确定性的条件考虑，又可以分为在任何情况下的不确定性和在某些条件下的不确定性两大类。对于上述不确定性类漏洞涉及的Java类和方法列表总结如表2所示。

表2：

{\footnotesize
\begin{longtable}[htb]{m{65pt} m{195pt} m{100pt}}
    \caption{不确定性类漏洞相关的Java类和方法列表} 
    \label{表-不确定性类漏洞相关的Java类和方法列表} \\
         \toprule    
         漏洞类型&相关类和方法&不确定性条件\\
\midrule
随机数生成&Math.random()&/\\
&new Random()&/\\
&new SecureRandom()&/\\
\midrule
时间戳依赖&System.currentTimeMillis()&/\\
&Calendar.getInstance()&/\\
&new Date()&/\\
\midrule
集合迭代顺序&new HashSet()&/\\
&new HashMap()&/\\
\midrule
程序并发&Thread.start()&/\\
&BaseStream<T,S>.parallel()&/\\
&StreamSupport.stream(Spliterator<T> s,boolean p)&仅当参数p为true时\\
\midrule
内存地址使用&Object.hashCode()&仅当运行时类没有以确\\
&Object.toString()&定性的方式重写方法时\\
\midrule
系统命令执行&Runtime.getRuntime().exec()&/\\
&new ProcessBuilder()&/\\
 \midrule
外部文件访问&new File()&/\\
&new FileReader()&/\\
&new FileInputStream()&/\\
 \midrule
环境变量获取&System.getenv()&/\\
        \bottomrule 
    \end{longtable} 
}